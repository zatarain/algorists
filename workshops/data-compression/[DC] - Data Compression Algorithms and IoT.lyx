#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}
\usetheme[oldstylearrows,nologo,numbers,zatarain]{CIMAT}

% or ...

\setbeamercovered{transparent}
% or whatever (possibly just delete it)
\usepackage[euler-digits]{eulervm}
\usefonttheme{professionalfonts}
\usepackage{dsfont}
%\usepackage[table]{xcolor}
%\usepackage{booktabs}

%\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{tcolorbox}
\usepackage{tabularx}
\usepackage{array}
\usepackage{colortbl}
\tcbuselibrary{skins,fitting}

\newcolumntype{Y}{>{\raggedleft\arraybackslash}X}

\DeclareMathOperator{\posdef}{+def}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\cov}{cov}
\DeclareMathOperator{\variance}{var}
\DeclareMathOperator{\lcp}{lcp}
\renewcommand{\mathbf}{\boldsymbol}
\DeclareMathOperator{\idv}{div}
\DeclareMathOperator{\diag}{diag}

\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}
\SetKwInOut{Data}{Parameters}
\SetKwInOut{Result}{output}
\SetKw{struct}{struct}
\SetKw{KwTo}{to}
\SetKw{KwRet}{return}
\SetKw{Return}{return}
\SetKwProg{Function}{function}{begin}{end}
\SetKwProg{lFunction}{function}{}{}
\SetKwBlock{Begin}{begin}{end}
\SetKwRepeat{Repeat}{repeat}{until}
\SetKwIF{If}{ElseIf}{Else}{if}{then:}{else if}{else:}{end}
\SetKwSwitch{Switch}{Case}{Other}{select}{for}{case}{otherwise}{end}{end}
\usepackage{algpseudocode}
\SetKwFor{For}{for}{do}{end}
\SetKwFor{ForPar}{parallel for}{do}{end}
\SetKwFor{ForEach}{for each}{do}{end}
\SetKwFor{ForAll}{for all}{do}{end}
\SetKwFor{While}{while}{do}{end}

\SetKw{Static}{static}
\SetKw{Const}{const}
\SetKw{Struct}{struct}
\SetKw{Class}{class}
\SetKw{New}{new}
\SetKw{Delete}{delete}
\SetKw{Char}{char}
\SetKw{Integer}{int}
\SetKw{Boolean}{bool}

\SetKwFunction{node}{node}
\SetKwFunction{sort}{std::sort}
\SetKwFunction{lcp}{lcp}
\SetKwFunction{strlen}{strlen}
\SetKwFunction{strcmp}{strcmp}
\SetKwFunction{compress}{compress}
\SetKwFunction{decompress}{decompress}
\SetKwFunction{pushback}{push-back}
\SetKwFunction{alphanumeric}{to-alpha}
\SetKwFunction{back}{back}
\SetKwFunction{neighborhood}{neighborhood}
\SetKwFunction{buildsuffix}{build-suffix-array}
\SetKwFunction{isEmpty}{is-empty}
\SetKwFunction{isNull}{is-null}
\SetKwFunction{isBetter}{can-improve}
\SetKwFunction{isUnvisited}{is-unvisited}
\SetKwFunction{isValid}{is-valid}
\SetKwFunction{improve}{visit-or-improve}
\SetKwFunction{mycomparator}{cmp}

\SetKwFunction{trie}{trie}
\SetKwFunction{map}{std::map}
\SetKwFunction{addword}{add-word}
\SetKwFunction{findword}{find-word}
\SetKwFunction{isEmpty}{is-empty}
\SetKwFunction{isNull}{is-null}

\SetSideCommentRight

\newcolumntype{Y}{>{\raggedleft\arraybackslash}X}

\tcbset{smallvalues/.style={enhanced,fonttitle=\bfseries,fontupper=\normalsize\sffamily,
colback=zorange!10!white,colframe=zorange!90!black,colbacktitle=zorange!90!white,
coltitle=white,center title}}
\end_preamble
\use_default_options false
\begin_modules
algorithm2e
\end_modules
\maintain_unincluded_children false
\language british
\language_package babel
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 0
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Data Compression and IoT
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Data Compression & IoT
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
optional, use only with long paper titles
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Author
Ulises Tirado Zatarain
\begin_inset space ~
\end_inset

 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Ulises Tirado Zatarain
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

(ulises.tirado@cimat.mx) 
\end_layout

\begin_layout Institute
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
1
\end_layout

\end_inset

Algorists Group
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Algorists
\end_layout

\end_inset


\end_layout

\begin_layout Date
July, 2016
\begin_inset Note Note
status collapsed

\begin_layout Itemize
Either use conference name or its abbreviation.
 
\end_layout

\begin_layout Itemize
Not really informative to the audience, more for people (including yourself)
 who are reading the slides online
\end_layout

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Jul, 2016
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
optional, should be abbreviation of conference name
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
If you have a file called "institution-logo-filename.xxx", where xxx is a
 graphic format that can be processed by latex or pdflatex, resp., then you
 can add a logo by uncommenting the following:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pgfdeclareimage[height=0.75cm]{cimat}{cimat.png}
\end_layout

\begin_layout Plain Layout


\backslash
logo{
\backslash
pgfuseimage{cimat}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The following causes the table of contents to be shown at the beginning
 of every subsection.
 Delete this, if you do not want it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSubsection[]{
\end_layout

\begin_layout Plain Layout

  
\backslash
frame<beamer>{ 
\end_layout

\begin_layout Plain Layout

    
\backslash
frametitle{Outline}   
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection,currentsubsection] 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
If you wish to uncover everything in a step-wise fashion, uncomment the
 following command:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
beamerdefaultoverlayspecification{<+->}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Outline
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Structuring a talk is a difficult task and the following structure may not
 be suitable.
 Here are some rules that apply for this solution: 
\end_layout

\begin_layout Itemize
Exactly two or three sections (other than the summary).
 
\end_layout

\begin_layout Itemize
At *most* three subsections per section.
 
\end_layout

\begin_layout Itemize
Talk about 30s to 2min per frame.
 So there should be between about 15 and 30 frames, all told.
\end_layout

\begin_layout Itemize
A conference audience is likely to know very little of what you are going
 to talk about.
 So *simplify*! 
\end_layout

\begin_layout Itemize
In a 20min talk, getting the main ideas across is hard enough.
 Leave out details, even if it means being less precise than you think necessary.
 
\end_layout

\begin_layout Itemize
If you omit details that are vital to the proof/implementation, just say
 so once.
 Everybody will be happy with that.
 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Definitions
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Definitions
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What is data compression?
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument 2
status collapsed

\begin_layout Plain Layout
Data compression
\end_layout

\end_inset

 Representation of information using less space than original data.
 The action to compress data is called 
\series bold
compression
\series default
 and the opposite actions is called 
\series bold
decompression
\series default
.
 It's a particular case of encoding/decoding information.
\end_layout

\begin_layout Itemize
Kinds of compression:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Loseless
\end_layout

\begin_layout Itemize
Lossy
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Loseless compression
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Information can be retrieved exactly as original data.
\end_layout

\begin_layout Itemize
Usually used for text compression
\end_layout

\begin_layout Itemize
Some known formats:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Zip
\end_layout

\begin_layout Itemize
GZip
\end_layout

\begin_layout Itemize
RAR
\end_layout

\begin_layout Itemize
ACE
\end_layout

\begin_layout Itemize
7Zip
\end_layout

\begin_layout Itemize
B2Zip
\end_layout

\begin_layout Itemize
...
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Lossy compression 
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Information loses some data, that cannot be retrieved exactly as before
 it is compressed.
\end_layout

\begin_layout Itemize
Usually used for media compression: images, audio, video.
\end_layout

\begin_layout Itemize
Some known formats:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
JPEG, GIF, PNG, ...
\end_layout

\begin_layout Itemize
MP3, OGG, AAC, ...
\end_layout

\begin_layout Itemize
H264, MPEG-4, VP8, ...
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Kinds of information
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<1->
\end_layout

\end_inset


\series bold
Redundant
\series default

\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<2->
\end_layout

\end_inset

Repetitive data
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<3->
\end_layout

\end_inset

Predictable data
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<4->
\end_layout

\end_inset


\series bold
Irrelevant
\series default

\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<5->
\end_layout

\end_inset

Invisible data
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<6->
\end_layout

\end_inset

Removing this data don't affect message content
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<7->
\end_layout

\end_inset


\series bold
Basic
\series default

\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<8->
\end_layout

\end_inset

Essential data
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<9->
\end_layout

\end_inset

It's needed to retrieve original data
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<10->
\end_layout

\end_inset

It should be transmitted
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Example/Problem
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Example
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Lets see an example: Fruit 100% random & 
\begin_inset Formula $\Im\left(country\right)$
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<1->{
\end_layout

\end_inset

There are six popular fruits in an imaginary random country with some states
 (about 32).
 People in the country implements an elections system to know: What's the
 favorite fruit ever in this random, imaginary and 100% hypothetical country?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<2->{
\end_layout

\end_inset


\begin_inset Graphics
	filename img/fruits.png
	lyxscale 50
	scale 30

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\backslash
visible<3->{
\end_layout

\end_inset


\begin_inset Graphics
	filename img/fruits-map.png
	lyxscale 50
	scale 15

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Frame
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<4->{
\end_layout

\end_inset

Can you see the different kinds of information?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Fruit 100% random & 
\begin_inset Formula $\Im\left(country\right)$
\end_inset

: Game rules
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
The election system has following rules:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<1->
\end_layout

\end_inset

Each citizen has an unique ID scanned from his/her ID card.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<2->
\end_layout

\end_inset

Each citizen can vote only once and only by one fruit.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<3->
\end_layout

\end_inset

If somebody tries to vote twice or more, then all votes from this citizen
 will be invalidated.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<4->
\end_layout

\end_inset

Any citizen can vote in any state.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<5->
\end_layout

\end_inset

There is a central system publishing partial live results.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<6->
\end_layout

\end_inset

Each state has a system to votes counting and this reports to the central
 system.
 This systems only can report (to central system) votes from citizens who
 are natives from that state.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<7->
\end_layout

\end_inset

In anytime the systems in each states can communicate with the other state
 systems to report votes from non-native citizens.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Some ideas and approaches
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Some ideas and approaches
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Logistics (brainstorming)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<1->
\end_layout

\end_inset

How people can vote?
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<2->
\end_layout

\end_inset

Is an app needed?
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<3->
\end_layout

\end_inset

How people can vote outside of their state? (non-native people)
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<4->
\end_layout

\end_inset

Infrastructure?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Architecture and design (brainstorming)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<1->
\end_layout

\end_inset

First, think in the small case (i.e.
 one server by state)
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<2->
\end_layout

\end_inset

Solve for this case
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<3->
\end_layout

\end_inset

Improve to solve big case (i.e.
 dividing each states by districts)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What about data transferring? (brainstorming)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Do you have some ideas for the system?
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<1->
\end_layout

\end_inset

One vote once?
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<2->
\end_layout

\end_inset

Several votes at once?
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<3->
\end_layout

\end_inset

What technology can we use?
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<4->
\end_layout

\end_inset

XML
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<5->
\end_layout

\end_inset

JSON
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<6->
\end_layout

\end_inset

Our own coding method?
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[fragile]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Data transferring: XML? (brainstorming)}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=XML,numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout
<?xml version="1.0" encoding="UTF-8" ?>
\end_layout

\begin_layout Plain Layout
<!DOCTYPE FruitCountry SYSTEM "votes.dtd">
\end_layout

\begin_layout Plain Layout
<state id="25">
\end_layout

\begin_layout Plain Layout
    <vote>
\end_layout

\begin_layout Plain Layout
        <citizen id="111999" />
\end_layout

\begin_layout Plain Layout
        <by>Apple</by>
\end_layout

\begin_layout Plain Layout
    </vote>
\end_layout

\begin_layout Plain Layout
    ...
\end_layout

\begin_layout Plain Layout
    <vote>
\end_layout

\begin_layout Plain Layout
        <citizen id="333777" />
\end_layout

\begin_layout Plain Layout
        <by>Strawberry</by>
\end_layout

\begin_layout Plain Layout
    </vote>
\end_layout

\begin_layout Plain Layout
</state>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[fragile]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Data transferring: JSON? (brainstorming)}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python,numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout
{
\end_layout

\begin_layout Plain Layout
    state: 25,
\end_layout

\begin_layout Plain Layout
    votes: [
\end_layout

\begin_layout Plain Layout
        { citizen: 111999, by: 'Apple' },
\end_layout

\begin_layout Plain Layout
        { citizen: 222888, by: 'Pear' },
\end_layout

\begin_layout Plain Layout
        { citizen: 222888, by: 'Banana' },
\end_layout

\begin_layout Plain Layout
        { citizen: 222888, by: 'Watermelon' },
\end_layout

\begin_layout Plain Layout
        ...
\end_layout

\begin_layout Plain Layout
        { citizen: 333777, by: 'Strawberry' }
\end_layout

\begin_layout Plain Layout
        { citizen: 333777, by: 'Orange' }
\end_layout

\begin_layout Plain Layout
    ]
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Data transferring: Our own coding method? (brainstorming)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<1->
\end_layout

\end_inset

What if we use some abreviations?
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A: Apple
\end_layout

\begin_layout Itemize
B: Banana
\end_layout

\begin_layout Itemize
O: Orange
\end_layout

\begin_layout Itemize
P: Pear
\end_layout

\begin_layout Itemize
S: Strawberry
\end_layout

\begin_layout Itemize
W: Watermelon
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<2->
\end_layout

\end_inset

Do we really need to send the citizen ID?
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<3->
\end_layout

\end_inset

Do we really need to send the state ID?
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<4->
\end_layout

\end_inset

Fixed width messages?
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<5->
\end_layout

\end_inset

A possible message from state to central system: 
\begin_inset Formula 
\[
\begin{array}{cc}
25 & AAAAPPPPPBBBBBWWWSSOOOOOAAA\end{array}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Section
Basic algorithms (Loseless)
\end_layout

\begin_layout Subsection
Run-Length Encoding
\begin_inset Argument 2
status open

\begin_layout Plain Layout
RLE Algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Run-Length Encoding (basic idea)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Block
\begin_inset Argument 2
status open

\begin_layout Plain Layout
RLE Algorithm
\end_layout

\end_inset

The idea is counting the times that each character appears consecutively.
 For example, for a string: 
\begin_inset Formula 
\[
S=aaaabbbbbbbbaaaaabbbbbbcccccbb
\]

\end_inset

 its compressed representation will be:
\begin_inset Formula 
\[
\tilde{S}=a4b8a5b6c5b2
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Run-Length Encoding (algorithm v1.0)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}[H]
\end_layout

\begin_layout Plain Layout


\backslash
Function{
\backslash
Char$*$ 
\backslash
compress{
\backslash
Const 
\backslash
Char $*input$}}{
\end_layout

\begin_layout Plain Layout

	
\backslash
Char $*str 
\backslash
leftarrow input$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
Char $*output 
\backslash
leftarrow$ 
\backslash
New 
\backslash
Char
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
Integer $length 
\backslash
leftarrow 0$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
While{$*str 
\backslash
neq 0$}{
\end_layout

\begin_layout Plain Layout

		
\backslash
Char $x 
\backslash
leftarrow$ $*str$
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\backslash
pushback{$output$,$x$}
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\backslash
Integer $k 
\backslash
leftarrow 1$
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\backslash
lWhile{$x = *(++str)$}{$k++$}
\end_layout

\begin_layout Plain Layout

		
\backslash
pushback{$output$,
\backslash
alphanumeric{$k$}}
\backslash
;
\end_layout

\begin_layout Plain Layout

		$length 
\backslash
leftarrow length + k + 1$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
Return{
\backslash
strlen{$output$} $< length$ ? $output$ : $input$}
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Run-Length Encoding (inconvenients)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<1->{
\end_layout

\end_inset

What about decompression?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<2->{
\end_layout

\end_inset

 Very simple, duh!
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<3->{
\end_layout

\end_inset

What happens if we got a compressed (and ambiguos) string like following?
\begin_inset Formula 
\[
\tilde{S}=a3\mathbf{15}b3
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<4->{
\end_layout

\end_inset

Maybe, original string was like:
\begin_inset Formula 
\[
S=aaa11111bbbb
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<5->{
\end_layout

\end_inset

Or maybe was:
\begin_inset Formula 
\[
S=aaa\cdots aaabbbb
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<6->{
\end_layout

\end_inset

Is this algorithm effective with XML or JSON?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Improving RLE
\begin_inset Argument 2
status open

\begin_layout Plain Layout
RLE (improved)
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Run-Length Encoding (improved v2.0)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<1->{
\end_layout

\end_inset

Maybe, we can use a separator/delimiter character?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<2->{
\end_layout

\end_inset

What character can we use to «,»,«|»,...?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<3->{
\end_layout

\end_inset

What if this character is in the original message? 
\begin_inset Formula 
\[
S=||||,,,\Rightarrow\tilde{S}=|4\boldsymbol{,},3\mbox{ or }\tilde{S}=|4\boldsymbol{|},3
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<4->{
\end_layout

\end_inset

What if we only have two kinds of characters?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<5->{
\end_layout

\end_inset

Thinking in binary :) 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<6->{
\end_layout

\end_inset

The Beattles - Let it «bit»! XD 
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<7->{
\end_layout

\end_inset


\begin_inset Formula 
\[
\begin{array}{c}
S="e><v"=\begin{array}{cccc}
00100101 & 00111110 & 00111100 & 01110110\end{array}\\
\tilde{S}=010001010001001001010101011100011011001010001
\end{array}
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<9->{
\end_layout

\end_inset


\series bold
FAIL!!
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<10->{
\end_layout

\end_inset

What if we limit the repetitions? (i.e.
 MAX 
\begin_inset Formula $9$
\end_inset

 repetitions)
\begin_inset Formula 
\[
\begin{array}{c}
S=aaaaaaaaaaaabbb\\
\tilde{S}=a9a3b3
\end{array}
\]

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Run-Length Encoding (improved v2.0)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<1->{
\end_layout

\end_inset

What if the number of repetitions always are represented by only one byte?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<2->{
\end_layout

\end_inset


\begin_inset Formula 
\[
\tilde{S}=a!b\#
\]

\end_inset

This compressed string represents 
\begin_inset Formula $33$
\end_inset

 
\begin_inset Formula $a$
\end_inset

's followed by 
\begin_inset Formula $35$
\end_inset

 
\begin_inset Formula $b$
\end_inset

's.
 Why?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
visible<3->{
\end_layout

\end_inset

The ASCII code of 
\begin_inset Formula $!$
\end_inset

 is 
\begin_inset Formula $33$
\end_inset

 and the code of 
\begin_inset Formula $\#$
\end_inset

 is 
\begin_inset Formula $35$
\end_inset

.
 Then, in this representation the 
\begin_inset Formula $2k$
\end_inset

-th characters are basic information and 
\begin_inset Formula $\left(2k+1\right)$
\end_inset

-th characters are number of repetitions, where 
\begin_inset Formula $k=0,1,2,\ldots,\frac{n}{2}$
\end_inset

.
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<4->{
\end_layout

\end_inset

What is the maximum repetition for a single character in this representation?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<5->{
\end_layout

\end_inset

How can detect corrupted data from compressed message?
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Run-Length Encoding (improved v2.0)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}[H]
\end_layout

\begin_layout Plain Layout


\backslash
Function{
\backslash
Char$*$ 
\backslash
compress{
\backslash
Const 
\backslash
Char $*input$}}{
\end_layout

\begin_layout Plain Layout

	
\backslash
Const 
\backslash
Char $MAX 
\backslash
leftarrow 
\backslash
sim0$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
Char $*str 
\backslash
leftarrow input$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
Char $*output 
\backslash
leftarrow$ 
\backslash
New 
\backslash
Char
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
Integer $length 
\backslash
leftarrow 0$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
While{$*str 
\backslash
neq 0$}{
\end_layout

\begin_layout Plain Layout

		
\backslash
Char $x 
\backslash
leftarrow *str$
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\backslash
pushback{$output$,$x$}
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\backslash
Char $k 
\backslash
leftarrow 1$
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\backslash
lWhile{$x = *(++str)$ 
\backslash
&
\backslash
& $k < MAX$}{$k++$}
\end_layout

\begin_layout Plain Layout

		
\backslash
pushback{$output$,$k$}
\backslash
;
\end_layout

\begin_layout Plain Layout

		$length 
\backslash
leftarrow length + k + 1$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
Return{
\backslash
strlen{$output$} $< length$ ? $output$ : $input$}
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Decompression from RLE
\begin_inset Argument 2
status open

\begin_layout Plain Layout
RLE (decompression)
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Run-Length Encoding (decompression)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}[H]
\end_layout

\begin_layout Plain Layout


\backslash
Function{
\backslash
Char$*$ 
\backslash
decompress{
\backslash
Const 
\backslash
Char $*input$}}{
\end_layout

\begin_layout Plain Layout

	
\backslash
Char $*c 
\backslash
leftarrow input$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
Char $*output 
\backslash
leftarrow$ 
\backslash
New 
\backslash
Char
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
While{$*c 
\backslash
neq 0$}{
\end_layout

\begin_layout Plain Layout

		
\backslash
Char $n 
\backslash
leftarrow *(c + 1)$
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\backslash
lFor{$i = 1$ 
\backslash
KwTo $n$}{ 
\backslash
pushback{$output$,$*c$} }
\end_layout

\begin_layout Plain Layout

		$c 
\backslash
leftarrow c + 2$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
Return{ $output$ }
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
More improves to RLE
\begin_inset Argument 2
status open

\begin_layout Plain Layout
RLE (PRO)
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Run-Length Encoding (improved v3.0)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Maybe we can do better:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<2->
\end_layout

\end_inset

We can analize input message to see what unique characters are contained
 in the mesage.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<3->
\end_layout

\end_inset

Then, we can construct a reduced alphabet.
 For example, 
\begin_inset Formula $\Sigma=\left\{ A,B,O,P,S,W\right\} $
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<4->
\end_layout

\end_inset

In this case only need 
\begin_inset Formula $3$
\end_inset

 bits to represent characters.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

<5->
\end_layout

\end_inset

We can use 
\begin_inset Formula $5$
\end_inset

 bits to store repetitions (so, we will have MAX 
\begin_inset Formula $31$
\end_inset

 repetitions by character).
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Run-Length Encoding (improved v4.0 PRO)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Moreover, what happens if we can detect whole words? 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
S=abcdabcdabcdbdbdbdbd
\]

\end_inset


\begin_inset Formula 
\[
\tilde{S}=\left[abcd\right]3\left[bd\right]4
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Section
Advanced algorithms (Loseless)
\end_layout

\begin_layout Subsection
Probability theory review
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Probability Review
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Probability basics
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Block
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Experiments and Events
\end_layout

\end_inset

An event is a set of posible results in an experiment execution.
 For example, taking a card from a deck or rolling a dice.
 We can denote all posible results with 
\begin_inset Formula $\Omega$
\end_inset

 and an event with uppercase letter such that 
\begin_inset Formula $A\subseteq\Omega$
\end_inset

 or 
\begin_inset Formula $A\in2^{\Omega}$
\end_inset

, then 
\begin_inset Formula $A$
\end_inset

 is a subset of 
\begin_inset Formula $\Omega$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Block
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Probability
\end_layout

\end_inset

Is an indicator that describes the frecuency of an event in one universal
 set of posibilities.
 Daily, we express that indicator as a percentage value or value between
 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

.
 Then we can define the probability as:
\begin_inset Formula 
\[
p:2^{\Omega}\mapsto\left[0,1\right]
\]

\end_inset


\end_layout

\begin_layout Block

\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Probability basics
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
So, when 
\begin_inset Formula $\Omega$
\end_inset

 is a discrete and finite set, then:
\begin_inset Formula 
\[
p\left(A\right)=\frac{\#A}{\#\Omega}
\]

\end_inset


\end_layout

\begin_layout Itemize
We name this as uniform distribution or counting distribution.
\end_layout

\begin_layout Itemize
However, counting elements in 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $\Omega$
\end_inset

 isn't always trivial.
 Maybe we need to use operations like factorial, combinations, permutations,
 etcetera.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Probability basics
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Key pressing random letter of the english keyboard such that the letter
 be a vowel.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Let 
\begin_inset Formula $A=\left\{ a,e,i,o,u\right\} $
\end_inset

 and 
\begin_inset Formula $\Omega=\left\{ a,...,z\right\} ,$
\end_inset

then 
\begin_inset Formula $p\left(A\right)=\frac{5}{26}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Rolling a dice such that the result be greater than 
\begin_inset Formula $2$
\end_inset

.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Let 
\begin_inset Formula $A=\left\{ 3,4,5,6\right\} $
\end_inset

 and 
\begin_inset Formula $\Omega=\left\{ 1,2,3,4,5,6\right\} ,$
\end_inset

then 
\begin_inset Formula $p\left(A\right)=\frac{2}{3}$
\end_inset

.,
\end_layout

\end_deeper
\begin_layout Itemize
Taking a card from a deck such that getting a red card.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Let 
\begin_inset Formula $A=\left\{ \mbox{A♥},\mbox{2♥},...,\mbox{10♥},\mbox{J♥},\mbox{Q♥},\mbox{K♥},\mbox{A♦},\mbox{2♦},...,\mbox{10♦},\mbox{J♦},\mbox{Q♦},\mbox{K♦}\right\} $
\end_inset

 and 
\begin_inset Formula $\Omega=\left\{ \begin{array}{cc}
\mbox{A♥},\mbox{2♥},...,\mbox{10♥},\mbox{J♥},\mbox{Q♥},\mbox{K♥}, & \mbox{A♦},\mbox{2♦},...,\mbox{10♦},\mbox{J♦},\mbox{Q♦},\mbox{K♦},\\
\mbox{A♠},\mbox{2♠},...,\mbox{10♠},\mbox{J♠},\mbox{Q♠},\mbox{K♠}, & \mbox{A♣},\mbox{2♣},...,\mbox{10♣},\mbox{J♣},\mbox{Q♣},\mbox{K♣}
\end{array}\right\} $
\end_inset

, then 
\begin_inset Formula $p\left(A\right)=\frac{1}{2}$
\end_inset

.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Data structure review
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Data Structures Review
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Priority Queue}
\end_layout

\begin_layout Plain Layout


\backslash
begin{block}{Wikipedia}
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item In computer science, a priority queue is an abstract data type which
 is like a regular queue or stack data structure, but where additionally
 each element has a "priority" associated with it.
 In a priority queue, an element with high  priority is served before an
 element with low priority.
 
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
item While priority queues are often implemented with heaps, they are conceptual
ly distinct from heaps.
 A priority queue is an abstract concept like "a list" or "a map";
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{block}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

%--------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{C++ STL Priority Queue}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{block}{std::priority
\backslash
_queue}
\end_layout

\begin_layout Plain Layout


\backslash
small template $<$class T, class Container = vector$<$T$>$,
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  class Compare = less$<$typename Container::value
\backslash
_type$>>$ class priority
\backslash
_queue;
\end_layout

\begin_layout Plain Layout


\backslash
end{block}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
textbf{Priority queue}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Priority queues are a type of container adaptors, specifically designed
 such that its first element is always the greatest of the elements it contains.
\end_layout

\begin_layout Plain Layout


\backslash
newline
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

%--------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout

The container shall be accessible through random access iterators and support
 the following operations:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

	
\backslash
item empty
\end_layout

\begin_layout Plain Layout

	
\backslash
item size
\end_layout

\begin_layout Plain Layout

	
\backslash
item front
\end_layout

\begin_layout Plain Layout

	
\backslash
item push
\backslash
_back
\end_layout

\begin_layout Plain Layout

	
\backslash
item pop
\backslash
_front
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The standard container classes vector and deque fulfill these requirements.
 By default, if no container class is specified for a particular priority
\backslash
_queue class instantiation, the standard container vector is used.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Tries
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Let a 
\series bold
word
\series default
 be a single string and let 
\series bold
dictionary
\series default
 be a large set of words.
\end_layout

\begin_layout Itemize
The 
\series bold
set
\series default
<
\series bold
string
\series default
> and the 
\series bold
hash tables
\series default
 can only find in a dictionary words that match exactly with the single
 word that we are finding.
\end_layout

\begin_layout Itemize

\series bold
Trie
\series default
 is a tree type data structure that allows to represent a dictionary.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We can insert and find strings in 
\begin_inset Formula $\mathcal{O}\left(L\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
We can perform incremental search.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Tries
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The word 
\series bold
trie
\series default
 is an infix of the word 
\begin_inset Quotes eld
\end_inset

re
\series bold
trie
\series default
val
\begin_inset Quotes erd
\end_inset

 because the trie can find a single word in a dictionary with only a prefix
 of the word.
\end_layout

\begin_layout Itemize
The trie is a tree where each vertex represents a single word or a prefix.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The root represents an empty string 
\begin_inset Formula $\varepsilon$
\end_inset

.
\end_layout

\begin_layout Itemize
A vertex that are 
\begin_inset Formula $k$
\end_inset

 edges of distance of the root have an associated prefix of length 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Itemize
Let 
\begin_inset Formula $v$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 be two vertexes of the trie, and assume that 
\begin_inset Formula $v$
\end_inset

 is a direct father of 
\begin_inset Formula $w$
\end_inset

, then 
\begin_inset Formula $v$
\end_inset

 must have an associated prefix of 
\begin_inset Formula $w$
\end_inset

.
\end_layout

\begin_layout Itemize
Deterministic acyclic finite state automaton.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Tries: Example
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The following trie stores the words: 
\begin_inset Quotes eld
\end_inset

algo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

assoc
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

all
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes erd
\end_inset

allocate
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

also
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

tree
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

trie
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/trie-sample.png
	lyxscale 50
	scale 20

\end_inset


\end_layout

\begin_layout Itemize
Note that every vertex of the tree does not store entire prefixes or entire
 words.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
How to represent tries?
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The most simple way to represent a trie is with an struct like following:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}[H]
\end_layout

\begin_layout Plain Layout


\backslash
Struct 
\backslash
trie $<$typename Type = int$>$ 
\backslash
Begin{
\end_layout

\begin_layout Plain Layout

    Type data
\backslash
;
\end_layout

\begin_layout Plain Layout

    
\backslash
Struct 
\backslash
trie *edge[ALPHABET
\backslash
_SIZE]
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
For the english alphabet, we can store the 
\begin_inset Formula $'a'$
\end_inset

-edge in 
\begin_inset Formula $trie::edge\left[0\right]$
\end_inset

, 
\begin_inset Formula $'b'$
\end_inset

-edge in 
\begin_inset Formula $trie::edge\left[1\right]$
\end_inset

, 
\begin_inset Formula $'c'$
\end_inset

-edge in 
\begin_inset Formula $trie::edge\left[2\right]$
\end_inset

 and so on until 
\begin_inset Formula $'z'$
\end_inset

-edge in 
\begin_inset Formula $trie::edge\left[25\right]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
How to add a word to dictionary?
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We can add a word 
\begin_inset Formula $w$
\end_inset

 as following: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}[H]
\end_layout

\begin_layout Plain Layout


\backslash
Function{
\backslash
addword{
\backslash
Struct 
\backslash
trie $*t$ , 
\backslash
Char $*w$}}{
\end_layout

\begin_layout Plain Layout

	
\backslash
uIf{
\backslash
isEmpty{w}}{
\end_layout

\begin_layout Plain Layout

	    $t->data
\backslash
longleftarrow t->data+1$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\backslash
Else{
\end_layout

\begin_layout Plain Layout

	    
\backslash
If{
\backslash
isNull{$t->edge
\backslash
left[*w
\backslash
right]$}}{
\end_layout

\begin_layout Plain Layout

			$t->edge
\backslash
left[*w
\backslash
right]
\backslash
longleftarrow$
\backslash
New 
\backslash
Struct 
\backslash
trie 
\backslash
;
\end_layout

\begin_layout Plain Layout

	    }
\end_layout

\begin_layout Plain Layout

	    
\backslash
addword{$t->edge
\backslash
left[*w
\backslash
right]$,$w+1$}
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
How to find a word in dictionary?
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
To find a word 
\begin_inset Formula $w$
\end_inset

, we can perform following algorithm:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}[H]
\end_layout

\begin_layout Plain Layout


\backslash
Function{
\backslash
findword{
\backslash
Struct 
\backslash
trie $*t$ , 
\backslash
Char $*w$}}{
\end_layout

\begin_layout Plain Layout

	
\backslash
lIf{
\backslash
isNull{$t$}}{
\backslash
Return{$0$}}
\end_layout

\begin_layout Plain Layout

	
\backslash
lIf{
\backslash
isEmpty{$w$}}{
\backslash
Return{$t->data$}}
\end_layout

\begin_layout Plain Layout

	
\backslash
Return{
\backslash
findword{$t->edge
\backslash
left[*w
\backslash
right],w+1$}}
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Subsection
Huffman Encoding
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Huffman Code
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Huffman Encoding
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The idea is...
 blah blah
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Section
Advanced algorithms (Lossy)
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Statistical
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Statistical Pattern Recognition
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Principal Component Analysis
\end_layout

\end_deeper
\begin_layout Itemize
Digital Signal Processing
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Filtering
\end_layout

\end_deeper
\begin_layout Itemize
Image compression
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Grayscale images
\end_layout

\begin_layout Itemize
Color images
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Section*
\start_of_appendix
Appendix
\end_layout

\begin_layout Subsection*
References
\end_layout

\begin_layout Frame
\begin_inset Argument 3
status collapsed

\begin_layout Plain Layout
allowframebreaks
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
References
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
beamertemplatebookbibitems
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia"
target "https://en.wikipedia.org/wiki/Double-ended_queue"

\end_inset


\end_layout

\end_deeper
\end_body
\end_document
